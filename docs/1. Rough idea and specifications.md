
**Standardized Multi‑API Integration: Architecture, Tooling & Templates**

**Goal:** Make it **fast, safe, and consistent** to add and troubleshoot 20–50 external APIs, while preserving a uniform developer experience and first‑class observability.\ **Scope:** Requirements, architecture, project layout, scaffolding templates, analyzers, MSBuild governance, NGINX config generation, CI/CD, and a day‑to‑day developer workflow.

---

**Table of Contents**

1. Requirements
2. Design Principles
3. Solution Architecture (4 Namespaces)
4. Observability & Correlation
5. Security, Compliance & Auditing
6. Project & Packaging Layout
7. Build Governance (MSBuild)
8. Template Pack & Scaffolding
9. Seed Projects & Placeholders
10. Roslyn Analyzer (External Layer Rules)
11. NGINX Generator Tool
12. Architecture Tests
13. Developer Workflow
14. CI/CD & Release
15. Acceptance Criteria
16. Troubleshooting Playbook
17. References
18. Certainty

---

**Requirements**

- **Uniform structure across 20–50 APIs** with four namespaces: **External**, **Domain**, **Internal**, **Client**.
- **External**:

- Directly derived from Swagger/OpenAPI; **Refit** interfaces; read configuration via IConfiguration.
- **No automatic retries**; expose **hooks** to capture **raw request/response JSON** and errors.
- Provide **DI extension** (e.g., AddMyApi()).
- Authentication is standardized (token/JWT/cert) via shared handlers.

- **Domain**:

- Higher‑level abstraction over External; map HTTP outcomes to **typed exceptions** that include **URL**, **request/response JSON**, **status code**, **correlation id** (via Exception.Data).
- **EF Core auditing** per API (tables with request/response JSON, status, duration, extracted keys).
- Support **guards/predicates** (whitelists, business rules) pre‑call; compose multi‑step flows.

- **Internal**:

- [ASP.NET](http://ASP.NET) Core controller/minimal APIs exposing selected Domain methods; return **ProblemDetails** with correlation id.

- **Client**:

- Friendly SDK to call the Internal API; surface nested error details to indicate **where** the failure occurred.

- **Usage policy**:

- Preferred: **Client SDK** → Internal API.
- Backend fast paths: **Domain** (auditing default‑ON).
- **Never** call External directly (kept **internal**).

- **NGINX** is a first‑class artifact: generate nginx.conf at build-time based on environment config; support load balancing.
- **Consistency enforcement** via **templates**, **MSBuild**, **Roslyn analyzers**, and **architecture tests**.

---

**Design Principles**

- **SOLID**—especially **Single Responsibility**:

- External = transport + hooks; Domain = orchestration + business mapping + audit; Internal = HTTP surface; Client = SDK.

- **Determinism**: Scaffolding done by **dotnet new templates**; LLM is used **only** to translate OpenAPI into DTOs + Refit methods **inside** the scaffold.
- **Shift‑left enforcement**: Roslyn analyzers and architecture tests fail builds/PRs when structure deviates.

**Why Refit (ApiResponse<T>) in External?** It preserves status, headers, request message, and raw content, enabling precise error mapping and auditing later.\ **Why DelegatingHandlers for hooks?** They capture the wire JSON without contaminating interface code, and work uniformly across all APIs.

Refit turns REST interfaces into live clients with DI support, and ApiResponse<T> exposes transport metadata.\ **Refs:** [Refit README](https://github.com/reactiveui/refit), [NuGet](https://www.nuget.org/packages/Refit)

---

**Solution Architecture (4 Namespaces)**

**External (transport only)**

- **Refit** interfaces returning Task<ApiResponse<T>>.
- Authentication via standardized **DelegatingHandler** (Bearer/JWT/cert).
- **ApiCallHooksDelegatingHandler** captures **raw request/response JSON** and errors, assigns a **CorrelationId**.
- **No retries**; **no business logic**; **internal visibility** with InternalsVisibleTo for Domain only.

InternalsVisibleTo lets External keep internal types while granting access to Domain; modern usage can be declared in the .csproj.\ **Refs:** InternalsVisibleTo, [Where to put it (SDK projects)](https://stackoverflow.com/questions/4234064/where-to-put-internalsvisibleto)

**Domain (orchestration, audit, guards)**

- Map HTTP outcomes to **typed exceptions** with full context in Exception.Data.
- **EF Core auditing** per API:

- **Single table** (Api_<ApiName>_Calls) or **split tables** (Requests/Responses), with **redaction** for secrets/PII.

- **Guards/predicates** pipeline:

- Mandatory guards (hard-coded); DI‑discoverable optional guards (e.g., whitelist account blocks).

- Multi‑step flows (POST → GET → POST), all recorded under one **correlation id**.

EF Core as the standard ORM; ProblemDetails is the recommended error envelope for HTTP APIs.\ **Refs:** EF Core, RFC 7807 Problem Details

**Internal (HTTP surface)**

- [ASP.NET](http://ASP.NET) Core controllers/minimal APIs, curated endpoints.
- Security (JWT), validation (optional FluentValidation).
- Responses standardized to **ProblemDetails** with correlation id.

[ASP.NET](http://ASP.NET) Core + OpenTelemetry makes tracing across requests straightforward.\ **Refs:** .NET Observability with OpenTelemetry

**Client (SDK)**

- Friendly SDK with typed methods; on errors, throw typed InternalApiException carrying ProblemDetails + correlation id.

---

**Observability & Correlation**

- **OpenTelemetry** (OTel) configured in the Internal host to collect **traces** and **correlate logs** automatically (TraceId, SpanId).
- Propagate **W3C traceparent** header; log correlation is automatic when an Activity is current.

OTel SDK auto‑correlates logs with traces, and [ASP.NET](http://ASP.NET) Core tracing is straightforward to enable.\ **Refs:** [OTel log correlation](https://opentelemetry.io/docs/languages/dotnet/logs/correlation/), [Getting started (ASP.NET Core traces)](https://opentelemetry.io/docs/languages/dotnet/traces/getting-started-aspnetcore/), MS Learn overview

---

**Security, Compliance & Auditing**

- **Redaction** before persistence (tokens/JWT/PII) in request/response JSON.
- **Retention** windows per API; encryption at rest; column masking where appropriate.
- **Auditing defaults**:

- Mutating operations (**POST/PUT/PATCH/DELETE**) → **Full** audit (redacted JSON).
- **GET** → **Minimal** (metadata + status/duration), unless endpoint returns sensitive data.

---

**Project & Packaging Layout**

**Mono‑repo** with one module per API (External/Domain/Internal/Client) plus shared packages:

/src

  /Common.Base            # hooks, auth handlers, options, exceptions, guards

  /Common.Analyzers       # Roslyn rules

  /External.<ApiX>        # internal Refit + handlers (not public)

  /Domain.<ApiX>          # public domain orchestration + audit

  /Internal.<ApiX>        # controllers; compiled into InternalHost

  /Client.<ApiX>          # public SDK

/apps

  /InternalHost           # web app hosting all Internal.<Api*> controllers

/tools

  /NginxConfGen           # config→nginx.conf generator

/tests

  /Architecture.<ApiX>.Tests

**Packaging strategy:**

- Publish **per‑API packages**: Company.Domain.ApiX, Company.Client.ApiX.
- Keep External.ApiX **internal** (not published).
- Optional **umbrella packages**: Company.Client.AllApis, Company.Domain.AllApis.

This modular approach is standard; avoid monolithic packages to preserve independent versioning. Architecture tests enforce boundaries.\ **Refs:** [NetArchTest](https://github.com/BenMorris/NetArchTest), [Code Maze intro](https://code-maze.com/csharp-architecture-tests-with-netarchtest-rules/)

---

**Build Governance (MSBuild)**

- **Directory.Build.props** centralizes TFMs, Nullable, analyzers, code‑style.
- **Directory.Build.targets** adds shared build steps (e.g., generate nginx.conf), and can fail builds on rule violations.

<!-- Directory.Build.targets -->

<Project>

  <Target Name="GenerateNginxConf" AfterTargets="Build">

    <Exec Command="dotnet run --project tools/NginxConfGen --config configs/nginx.servers.json --out artifacts/nginx/$(Configuration)/nginx.conf" />

  </Target>

</Project>

MSBuild supports repo‑wide customization via these files; it’s the recommended way to govern multi‑project solutions.\ **Refs:** Directory.Build.props/targets

---

**Template Pack & Scaffolding**

- A **dotnet new template pack** guarantees deterministic scaffolding for each new API module.
- Template **parameters**: --ApiName, --DbSchema, --TableMode {Single|Split}, --EnableAuditing, --SolutionFolder.

**template.json overview** (simplified):

{

  "$schema": "[http://json.schemastore.org/template](http://json.schemastore.org/template)",

  "identity": "Company.ApiModule.Templates",

  "shortName": "company-apimodule",

  "sourceName": "ApiModuleSeed",

  "symbols": {

    "ApiName": { "type":"parameter","datatype":"text","replaces":"ApiModuleSeed" },

    "DbSchema": { "type":"parameter","datatype":"text","replaces":"{{DB_SCHEMA}}","defaultValue":"Audit" },_

    _"TableMode": { "type":"parameter","datatype":"choice","choices":[{"choice":"Single"},{"choice":"Split"}],"replaces":"{{TABLE_MODE}}","defaultValue":"Single" },

    "EnableAuditing": { "type":"parameter","datatype":"bool","replaces":"{{ENABLE_AUDIT}}","defaultValue":"true" },_

    _"SolutionFolder": { "type":"parameter","datatype":"text","replaces":"{{SOLUTION_FOLDER}}","defaultValue":"src" }

  }

}

The template engine uses runnable projects with template.json; installing via NuGet or a folder is supported.\ **Refs:** Custom templates (dotnet new), Tutorial

**Scaffolding scripts** (scripts/new-api.ps1 / .sh):

dotnet new company-apimodule \

  --ApiName NedCase \

  --DbSchema Audit \

  --TableMode Single \

  --EnableAuditing true \

  --SolutionFolder src

dotnet restore

dotnet build -warnaserror

---

**Seed Projects & Placeholders**

Each module is scaffolded with **compilable seed projects** (External/Domain/Internal/Client) and tests. Key placeholders:

- ApiModuleSeed → replaced by ApiName.
- {{DB_SCHEMA}} → EF Core schema.
- {{ENABLE_AUDIT}} → defaults for Domain auditing.
- Config sections: Apis:ApiModuleSeed, Domains:ApiModuleSeed.

(See previous seeds provided: IMyApi internal, hooks delegating handler, Domain service mapping, EF entity/table name Api_<ApiName>_Calls.)

---

**Roslyn Analyzer (External Layer Rules)**

**Package:** Company.Common.Analyzers\ **Diagnostics:**

- **CMP001** – All types in External.* must be **internal**.
- **CMP002** – Refit methods in External.* must return **Task<ApiResponse<T>>**.
- **CMP003** – **No Polly** (retry/resilience) usage in External.*.
- **CMP005** – Refit interfaces in External.* must be **internal**.

Minimal **CodeFixes** add:

- Change public → internal.
- Change return type to Task<ApiResponse<object>> (developer refines the T DTO).

Authoring analyzers and packaging them for CI enforcement follows standard Roslyn guidance.\ **Refs:** Write your first analyzer, [Roslyn wiki](https://github.com/dotnet/roslyn/blob/main/docs/wiki/Getting-Started-Writing-a-Custom-Analyzer-&-Code-Fix.md)

---

**NGINX Generator Tool**

**Project:** /tools/NginxConfGen (net8.0 console app)\ **Inputs:** configs/nginx.servers.json (algorithm, servers, passive health thresholds).\ **Output:** artifacts/nginx/<Configuration>/nginx.conf (via Directory.Build.targets).

**Supported algorithms:**

- **Round‑robin** (default), **least_conn**, **ip_hash**.\ **Health checks:**
- **Passive** in OSS using max_fails + fail_timeout.
- **Active** health checks require **NGINX Plus** (health_check directive).

NGINX supports these load‑balancing methods; passive health checks are OSS‑friendly, active checks are Plus‑only.\ **Refs:** [NGINX load balancing](https://nginx.org/en/docs/http/load_balancing.html), [Admin guide (methods)](https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/), [HTTP health checks](https://docs.nginx.com/nginx/admin-guide/load-balancer/http-health-check/)

Example emitted nginx.conf:

events { worker_connections 1024; }_

_http {_

  _upstream internal_api {

    least_conn;_

    _server app01.example.local:8080 max_fails=3 fail_timeout=30s;_

    _server app02.example.local:8080 max_fails=3 fail_timeout=30s;_

  _}_

  _server {_

    _listen 80;_

    _server_name internal.example.local;

    location / {

      proxy_pass [http://internal](http://internal)_api;

      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

      proxy_set_header Host $host;

    }

  }

}

---

**Architecture Tests**

Use **NetArchTest** to enforce cross‑assembly rules (run in /tests/Architecture.<Api>.Tests):

- Client.* **must not** depend on External.*.
- Internal.* **must not** depend on External.*.
- Domain.* **must** depend on External.*.

Architecture tests complement analyzers by validating **assembly dependencies**.\ **Refs:** [NetArchTest](https://github.com/BenMorris/NetArchTest), [Code Maze tutorial](https://code-maze.com/csharp-architecture-tests-with-netarchtest-rules/)

---

**Developer Workflow**

1. **Scaffold** a new API module:

./scripts/new-api.sh NedCase Audit Single true

2. **Use the LLM** to **generate DTOs + Refit methods** _inside_ External.<ApiName> based on OpenAPI.

- The analyzer will fail if methods return Task<T> or types are public.

4. **Implement Domain** orchestration, guards, and auditing (stubs provided).
5. **Expose Internal** endpoints (controller/minimal APIs).
6. **Build & test**: analyzers + architecture tests enforce rules; nginx.conf is generated.

---

**CI/CD & Release**

- **Pipelines**:

- Build with **warnings as errors**.
- Run **unit tests** and **architecture tests**.
- Package **Domain**/**Client** per API; optionally **Client.AllApis**.
- Publish **InternalHost** (single service hosting all internal endpoints).
- Upload **nginx.conf** artifact per environment.

- **Versioning:** Semantic per API (MAJOR.MINOR.PATCH); umbrellas pin major versions.

---

**Acceptance Criteria**

- External:

- Refit interfaces compile as **internal** and return Task<ApiResponse<T>>.
- Hooks capture raw JSON; DI Add<ApiName>Api(...) works.

- Domain:

- Exceptions include **Url**, **RequestJson**, **ResponseJson**, **StatusCode**, **CorrelationId**.
- EF Core audit tables created in **{{DB_SCHEMA}}** with **Single** or **Split** pattern.
- Guards block disallowed operations.

- Internal:

- Endpoints return **ProblemDetails** with correlation id on errors.

- Client:

- SDK methods call Internal; exceptions carry nested details.

- Observability:

- OTel traces + logs correlated automatically.

- Build:

- Analyzers & architecture tests pass; nginx.conf generated.

---

**Troubleshooting Playbook**

1. **Grab CorrelationId** from Client exception or Internal ProblemDetails.
2. Query the per‑API **audit table** by CorrelationId.
3. Inspect **raw request/response JSON**, **status**, **duration**.
4. Determine **fault location**:

- External 5xx → raise with provider team.
- Domain guard failure → fix business rule/config.
- Internal 4xx/5xx → controller/validation issue.

6. Use **OTel traces** to walk the spans across Client→Internal→Domain→External.

---

**References**

- **dotnet templates:**\ Microsoft Learn: Custom templates for dotnet new, Tutorial—Create a project template
- **MSBuild governance:**\ Microsoft Learn: Customize build by directory (Directory.Build.props/targets)
- **Roslyn analyzers:**\ Microsoft Learn: Write your first analyzer/code fix, Roslyn wiki: [Getting started](https://github.com/dotnet/roslyn/blob/main/docs/wiki/Getting-Started-Writing-a-Custom-Analyzer-&-Code-Fix.md)
- **Refit:**\ GitHub: [Refit README](https://github.com/reactiveui/refit), NuGet: [Refit 9.x](https://www.nuget.org/packages/Refit)
- **InternalsVisibleTo:**\ Microsoft Learn: API docs
- **Architecture tests:**\ GitHub: [NetArchTest](https://github.com/BenMorris/NetArchTest), Guide: [Code Maze](https://code-maze.com/csharp-architecture-tests-with-netarchtest-rules/)
- **OpenTelemetry:**\ MS Learn: .NET Observability, OTel docs: [Log correlation](https://opentelemetry.io/docs/languages/dotnet/logs/correlation/), [ASP.NET Core traces](https://opentelemetry.io/docs/languages/dotnet/traces/getting-started-aspnetcore/)
- **NGINX:**\ [nginx.org](http://nginx.org): [Using NGINX as HTTP load balancer](https://nginx.org/en/docs/http/load_balancing.html), NGINX docs: [HTTP load balancing methods](https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/), [HTTP health checks](https://docs.nginx.com/nginx/admin-guide/load-balancer/http-health-check/)

---
